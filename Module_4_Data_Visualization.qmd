---
title: "Módulo 4 | Visualização de dados"
author: "A. Peralta-Santos"
date: today
lang: pt
date-format: long
format:
  html:
    smooth-scroll: true
    embed-resources: true
    code-copy: true
    code_download: true
    toc: true
    toc-location: left
theme: cosmo
smooth-scroll: true
execute:
  warning: false
project:
  output-dir: outputs/documents
---

# PRINCIPIOS DE VISUALIZAÇÃO

*por Cédric Scherer*

**1.  INFORMAÇÃO** (integridade) Apresentar os dados de forma precisa e honesta, sem manipular ou distorcer os fatos para enganar o público.

**2.  HISTÓRIA** (interesse) Narrativa cativante dentro da visualização de dados, tornando a informação não apenas informativa, mas também envolvente e memorável para o espectador.

**3.  OBJETIVO** (utilidade) Garantir que a visualização de dados sirva a um propósito claro, seja para informar, persuadir, educar ou apoiar a tomada de decisões.

**4.  FORMA VISUAL** (beleza) Valor do design esteticamente agradável na visualização de dados, que realça a experiência do leitor e pode tornar as informações complexas mais acessíveis e compreensíveis.

**5.  Dicas úteis** *Layout Limpo --- "menos é mais"*

-   Use anotações diretas para melhorar a legibilidade e interpretabilidade.
-   Utilize hierarquia para orientar o leitor.
-   Uso consistente de cores, espaçamento, tipos de letra e peso.
-   Use cores sabiamente e certifique-se de que funcionam para pessoas com daltonismo.
-   As informações mais importantes devem receber a principal atenção.

![Exemplo por Cédric Scherer](images/exemplo_viz.png)\

## Valor da vizualização

**... make both calculations and graphs. Both sorts of output should be studied; each will contribute to understanding.**\
F. J. Anscombe (1973)

"Há uma razão pela qual os cientistas de dados gastam tanto tempo explorando dados usando gráficos. Confiar apenas em medidas de tendencia e dispersão como médias, variâncias e correlações pode ser perigoso, porque conjuntos de dados muito diferentes podem dar resultados semelhantes.

Este é um princípio que tem sido demonstrado em aulas de estatística por décadas com o Quarteto de Anscombe: quatro gráficos de dispersão que, apesar de serem qualitativamente diferentes, têm a mesma média e variância e a mesma correlação entre eles."

![Todas as distribuições têm a mesma média e variancia](images/datasauros.png)

## Boas práticas 

**1. Saber quando usar 0 na escala** 
"Ao usar gráficos de barras, é enganoso não começar as barras a partir de 0. Isso porque, ao usar um gráfico de barras, estamos implicando que o comprimento é proporcional às quantidades exibidas. Ao evitar o 0, diferenças relativamente pequenas podem parecer muito maiores do que realmente são. Essa abordagem é frequentemente usada por políticos ou organizações de mídia tentando exagerar uma diferença."


**2. Ordenar os valores **
Quando um dos eixos é usado para mostrar categorias, como é feito em gráficos de barras, o comportamento padrão do ggplot2 é ordenar as categorias alfabeticamente quando são definidas por cadeias de caracteres. Se forem definidas por fatores, são ordenadas pelos níveis dos fatores. Raramente queremos usar a ordem alfabética. Em vez disso, devemos ordenar por uma quantidade significativa.

**3. Uso da cor **
Ao criar visualizações de dados, é crucial escolher a escala de cores adequada para transmitir informações de forma eficiente e precisa. Aqui estão as boas práticas sobre quando usar escalas de cores sequenciais, qualitativas e divergentes:

1. **Escala de Cores Sequencial**: 
   - **Uso**: Ideal para representar dados quantitativos que possuem uma ordem natural ou progressão, como temperaturas, idades ou níveis de renda.
   - **Características**: Apresenta uma progressão suave de cores, geralmente variando de claras a escuras ou vice-versa.

2. **Escala de Cores Divergente**: 
   - **Uso**: Ideal para dados que possuem um ponto central importante, como variações em relação a uma média ou zero.
   - **Características**: Combina duas escalas de cores sequenciais com um ponto de transição, geralmente ao redor de um valor médio, destacando desvios em duas direções opostas.
   
3. **Escala de Cores Qualitativa**: 
   - **Uso**: Adequada para dados categóricos sem ordem ou classificação inerente, como grupos de países, tipos de produtos ou categorias de serviços.
   - **Características**: Composta por cores distintas que facilitam a diferenciação entre as categorias. 
   - **Exemplo Prático**: Em um gráfico de barras mostrando vendas por categoria de produto, cada categoria (como eletrônicos, vestuário, alimentos) pode ser representada por uma cor diferente.


![Uso da cor por Cedir Scherer](images/uso_cor.png)

**4. Pensar nos daltonicos **
Podemos usar uma serie de cores que conseguem ser percepcionadas por daltonicos.


## Exemplos de visualização de dados

### Alterações climáticas

![Yearly fluctuations in area of Arctic covered by ice](images/climate_change_photo.png)

Fonte <https://www.nytimes.com/interactive/2015/03/24/science/earth/arctic-ice-low-winter-maximum.html>

### COVID-19

![Excesso de Mortes por COVID-19](images/covid19.png) 

Fonte <https://www.ft.com/content/f1a270c3-3870-46ad-99e8-45b5d8f127e0>


## Outros recursos 

Qual o tipo de gráfico que devo escolher?

Exempleos de websites onde podemos pesquisar qual o melhor gráfico para cada situação.

[Data to viz website](https://www.data-to-viz.com/)

[Data to viz project](https://datavizproject.com/)

[Principles of good visuals](https://github.com/GraphicsPrinciples/CheatSheet/blob/master/NVSCheatSheet.pdf)

# GGPLOT

o ggplot é uma gramatica de graficos, em que cada elemento é uma instrução para a elaboração do grágico final

Contem os seguintes elementos

**1.  data:** O componente de dados.

**2.  geom:** É o tipo de gráfico. p.e. gráfico de barras, histograma, densidades suaves, qqplot e boxplot.

**3.  mapping:** Posições dos pontos no eixo x e eixo y. Cada ponto representa uma observação diferente, e mapeamos dados sobre essas observações para pistas visuais como escalas x e y. A cor é outra pista visual que mapeamos para a região. Referimo-nos a isso como o componente de mapeamento estético. Como definimos o mapeamento depende da geometria que estamos usando.

**4.  Facets:** semelhante ao agrupar por

**5.  Theme:** Tema do grafico p.e. preto e branco, especifico para mapas

**6.  Labels:** define outros elementos do gráfico como titutlo, legendas

![Anatomia do ggplot by Cedric Scherer ](images/ggplot_themes.png)



```{r}
# Packages
required_packages <- c(
                       "tidyverse",
                       "rio",
                       "scales",
                       "here",
                       "patchwork",
                       "sf", 
                       "ggthemes",
                       "giscoR",
                       "eurostat",
                       "sysfonts", 
                       "showtext", 
                       "scales",
                       "geodata", 
                       "osmdata", 
                       "leaflet"
                       )      

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}
remove(required_packages)
remove(pkg)
```

```{r}
rm(list = ls(all.names = TRUE)) #will clear all objects includes hidden objects.

```

```{r}
# change outpurs to output
inpatient_hospital_lite <- import("output/datasets/inpatient_hospital_lite.csv")

## são equivalentes

inpatient_hospital_lite <- import(here("output", "datasets", "inpatient_hospital_lite.csv"))
```

## Data and aestetics

```{r}
# 1. Vamos definir só os dados 
ggplot(data = inpatient_hospital_lite)
```

```{r}
# 2. Definir o eixo dos X e Y
ggplot(
  data = inpatient_hospital_lite, 
  mapping = aes(x = tipo_instituicao, y = doentes_saidos_var)
)
```

```{r}
# Carregar o pacote ggplot2 para visualização de dados
# library(ggplot2)

# Criar um gráfico de boxplot com o conjunto de dados 'inpatient_hospital_lite'
ggplot(data = inpatient_hospital_lite, 
       mapping = aes(x = tipo_instituicao,  # Variável categórica no eixo x
                     y = doentes_saidos_var) # Variável numérica no eixo y
       ) +
  geom_boxplot()  # Utilizar o geom_boxplot para criar o gráfico de caixa

```

```{r}
# Criar um objeto ggplot e armazená-lo na variável 'p'
p <- ggplot(data = inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +  # Definir as variáveis do gráfico
  geom_boxplot()  # Adicionar um gráfico de caixa

# Exibir o gráfico armazenado no objecto 'p'
p
```

## Geometrics

### Box plot

::: callout-important
No ggplot2, é possível criar uma estrutura de gráfico básica sem vinculá-la diretamente a um conjunto de dados específico. 

Esta abordagem permite adicionar múltiplas camadas ao gráfico, cada uma podendo vir de um conjunto de dados diferente, mas que devem compartilhar as mesmas variáveis nos eixos x e y.
:::

```{r}
# Criar um gráfico de boxplot sem mostrar outliers
p1 <- inpatient_hospital_lite |> 
  ggplot() +  # Iniciar a construção do gráfico
    geom_boxplot(aes(x = tipo_instituicao, 
                     y = doentes_saidos_var),  # Definir as variáveis x e y
                  outlier.shape = NA)  # Excluir os outliers do gráfico

# Exibir o gráfico
p1
```

## Facets

A facetação é uma técnica poderosa que permite dividir um gráfico em múltiplos subgráficos menores, chamados facetas, com cada faceta representando um subconjunto dos dados baseado em uma ou mais variáveis categóricas. Isso é particularmente útil para comparar padrões dentro de diferentes níveis ou categorias de uma variável (ou variáveis) em um conjunto de dados. 

```{r}
# Criar um gráfico de boxplot usando o conjunto de dados 'inpatient_hospital_lite'

p1 <- ggplot(data = inpatient_hospital_lite, 
             aes(x = tipo_instituicao,  # Definir as variáveis para os eixos x e y
                 y = doentes_saidos_var)
             ) +  
  geom_boxplot(outlier.shape = NA) +  # Criar um gráfico de caixa sem mostrar outliers
  facet_wrap(~tipo_de_especialidade)  # Dividir o gráfico em facetas com base na variável 'tipo_de_especialidade'

# Exibir o gráfico
p1

```

## Labels

```{r}
# Podemos adicionar o titutlo, nomes do eixos e fonte

p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_boxplot(outlier.shape = NA) + 
  labs(title = "Number of inpatients discharged in Hospitals", # Titulo
         subtitle = "2015-2022", # Subtitulo
         y = "Number of inpatients discharged", # Eirxo dos Y
         x = "Type of hospital", # Eixo dos X
         caption = "Source: Ministry of Health, Portugal", # Fonte
         tag = "A") # Tag da imagem, util em textos com imagens multiplas
p1
```

## Theme

Define a estetica do gráfico, tamanhos de letra, alinhamentos, cores do fundo

```{r}
# Theme classic

# Criar um gráfico de boxplot usando o conjunto de dados 'inpatient_hospital_lite'
p1 <- ggplot(data = inpatient_hospital_lite, 
             aes(x = tipo_instituicao, y = doentes_saidos_var)) +  # Definir as variáveis para os eixos x e y
  
  geom_boxplot(outlier.shape = NA) +  # Criar um gráfico de caixa sem mostrar outliers
  
  labs(title = "Number of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo do gráfico
       y = "Number of inpatients discharged",  # Etiqueta do eixo y
       x = "Type of hospital",  # Etiqueta do eixo x
       caption = "Source: Ministry of Health, Portugal") +  # Legenda da fonte de dados
  theme_classic()  # Aplicar um tema clássico ao gráfico

# Exibir o gráfico
p1
```

```{r}
# Theme Black and white
# Good for publishing

p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_boxplot( outlier.shape = NA) + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of  hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  
  theme_bw()  

p1
```

```{r}
# Theme The Economist
# O package ggthemes permite facilmente adoptar estilos pré-definidos de temas

p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_boxplot( outlier.shape = NA) + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of  hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  
  theme_economist()  

p1
```

### Criar o proprio tema

Podemos criar o nosso proprio tema como um objecto e depois invocar esse tema para os nossos objectos ggplot

```{r}
# Criar o tema 
theme_r_datascience <- 
  theme_bw() + 
  theme(
    plot.title = element_text(face = "bold", size = 12),
    legend.background = element_rect(
      fill = "white", 
      linewidth = 4, 
      colour = "white"
    ),
    legend.justification = c(0, 1),
    legend.position = c(0, 1),
    axis.ticks = element_line(colour = "grey70", linewidth = 0.2),
    panel.grid.major = element_line(colour = "grey70", linewidth = 0.2),
    panel.grid.minor = element_blank()
  )

```

::: callout-important
Este recurso é bastante útil porque permite alterar completamente o tema <https://www.rdocumentation.org/packages/ggplot2/versions/3.4.4/topics/theme>
:::


```{r}
p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_boxplot( outlier.shape = NA) + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of  hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  
  theme_r_datascience  

p1
```

### Alterar um tema existente

```{r}

# Carregar os pacotes necessários para manipulação de fontes
library(sysfonts)
library(showtext)

# Adicionar fontes do Google
font_add_google("Open Sans", family = "Open Sans") # Adiciona a fonte 'Open Sans'
font_add_google("Special Elite", family = "special") # Adiciona a fonte 'Special Elite'

# Ativar automaticamente o uso de fontes personalizadas nos gráficos
showtext_auto()


# Configurar o tema global para todos os gráficos ggplot
theme_set(theme_minimal()) # Define 'theme_minimal' como o tema padrão
theme_replace(text = element_text(family = "Open Sans")) # Altera a fonte padrão para 'Open Sans'

# Ao definir com o theme set todos os plot estarão com o minimal com Open Sans a não ser que passemos um argumento de tema 
```

```{r}
p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_boxplot( outlier.shape = NA) + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of  hospital", 
         caption = "Source: Ministry of Health, Portugal")
p1
```

## Anotações

```{r}
# Limitar o eixo dos Y a um máximo de 4000
p2<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_point() +
  geom_boxplot(outlier.shape = TRUE) + 
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  ylim(0,4000) +
  annotate(
    geom = "text",
    x = "Hospital",
    y = 4000,
    label = "What happened here?",
    color = "firebrick",
  )

p2
```

```{r}
# Limitar o eixo dos Y a um máximo de 4000
p2<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_point() +
  geom_boxplot(outlier.shape = TRUE) + 
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  ylim(0,4000) +
  annotate(
    geom = "text",
    x = "Hospital",
    y = 4000,
    label = "What happened here?",
    color = "firebrick",
  ) 

p2
```



## Outros elementos

```{r}
# Limitar o eixo dos Y a um máximo de 4000
p2<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, y = doentes_saidos_var)) +
  geom_point() +
  geom_boxplot(outlier.shape = NA) + 
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  ylim(0,4000) 

p2
```

```{r}
# Alterar a cor de preenchimentos do box plot 

p_final_1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, 
                y = doentes_saidos_var)
            ) +
  geom_boxplot(outlier.shape = NA,
               fill = "gray", 
               colour = "black") + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  ylim(0,4000)
  #theme(plot.background = element_rect("white")
        #)

 p_final_1
```

## Tamanho e aspecto 

**Podemos não depender exclusivamente do painel de visualização do RStudio!**

Quando o protótipo de gráfico estiver quase pronto, decida um tamanho fixo para o gráfico.

**Abordagem 1:** salvar o grafico e inspecioná-lo e repetir.
Isso pode ser chato e demorado...

**Abordagem 2:** usar um qmd ou rmd com saída inline e configurações de chunk.
Definir fig-width / fig.width e fig-height / fig.height por chunk ou globalmente.

```{r}
#| label: fig-boxplot
#| fig-cap: "Number of inpatients discharged in Hospitals from 2015-2022, in Portugal"
#| fig-width: 7
#| fig-height: 5
#| warning: false

p_final_1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, 
                y = doentes_saidos_var)
            ) +
  geom_boxplot(outlier.shape = NA,
               fill = "gray", 
               colour = "black") + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  ylim(0,4000)
  #theme(plot.background = element_rect("white")
        #)

 p_final_1
```

## Save plot

Podemos gravar o nosso gráfico em vários formatos

```{r}
# ggsave | Salva o último gráfico na memória
# Podemos usar o pacote aqui para especificar o diretório de saída
# Podemos especificar o formato de saída
# O tamanho
# A resolução em dpi

ggsave(
  p_final_1,
  filename = here::here("output", 
                        "figures", 
                        paste0( "hospital_inpatients", ".png")),
  width = 20,
  height = 10,
  units = c("cm"),
  dpi = "retina",
  bg = "white"
)
```

```{r}
# Podemos alterar o formato do grafico para PDF

ggsave( filename = "output/figures/hospital_inpatients.pdf",
        plot= p_final_1,
        width = 25.49,
        height = 12.3,
        units = c("cm"),
        dpi = 600 )
```

```{r}
# Podemos alterar o formato para JPEG 

ggsave( filename = here::here("output_figures", 
                  paste0( "hospital_inpatients", ".jpeg")),
        plot= p_final_1,
        width = 25.49,
        height = 12.3,
        units = "cm",
        dpi = 600 )
```

# TIPOS DE GRÁFICOS

## VISUALIZAR DISTRIBUIÇÕES

Existem vários tipos de gráficos no R que podem ser usados para visualizar distribuições, cada um adequado para diferentes tipos de dados e análises. Aqui estão alguns dos tipos mais comuns de gráficos para visualizar distribuições, juntamente com uma breve explicação de seu uso:

**Gráfico de Densidade (Density plot)**
Descrição: Similar ao histograma, mas mostra uma linha contínua que representa a distribuição de probabilidade estimada dos dados.
Uso: Bom para visualizar a forma da distribuição, especialmente útil para comparar distribuições entre diferentes grupos.

**Histograma (Histogram)**
Descrição: Mostra a frequência de diferentes intervalos (ou "bins") de uma variável numérica.
Uso: Útil para entender a forma e a dispersão de uma distribuição univariada.

**Gráfico de Caixa (Boxplot)**
Descrição: Representa a mediana, os quartis e os outliers dos dados.
Uso: Excelente para comparar a distribuição de uma variável numérica entre diferentes grupos categóricos e para identificar outliers.

**Jitter Plot**
Descrição: No gráfico de dispersão com jitter, uma pequena quantidade de ruído aleatório (jitter) é adicionada à posição dos pontos. Isso ajuda a separar visualmente os pontos que, de outra forma, cairiam exatamente na mesma posição.
Uso: É particularmente útil quando você tem muitos pontos de dados que estão alinhados verticalmente ou horizontalmente devido à sua natureza discreta ou categórica. O jitter ajuda a visualizar a densidade desses pontos e a evitar que eles se sobreponham, o que pode obscurecer a quantidade real de dados em qualquer posição específica.

### Gráfico de Densidade (Density plot)  

```{r}

p1<- ggplot(data=inpatient_hospital_lite, 
       aes(x=doentes_saidos_var)
       ) +
  geom_density() +
  labs(title = "Doentes Saídos",
         subtitle = "Hospitais 2015-2022",
         y = "Densidade",
         x = "Número de doentes saídos", 
         caption = "Source: Ministry of Health, Portugal") +

  theme_minimal()

p1
```

Por tipo de especialidade

```{r}

p1<- ggplot(data=inpatient_hospital_lite, 
       aes(x=doentes_saidos_var,
           fill=tipo_de_especialidade)
       ) +
  geom_density(alpha=.4) +
    labs(title = "Doentes Saídos",
         subtitle = "Hospitais 2015-2022",
         y = "Densidade",
         x = "Número de doentes saídos", 
         caption = "Source: Ministry of Health, Portugal") +

  theme_minimal()

p1
```

### Histograma (Histogram)

```{r}

p1<- ggplot(data=inpatient_hospital_lite, 
       aes(x=doentes_saidos_var,
           fill=tipo_de_especialidade)
       ) +
  geom_histogram(alpha=.4) +
    labs(title = "Doentes Saídos",
         subtitle = "Hospitais 2015-2022",
         y = "Contagem da frequência de doentes saídos",
         x = "Número de doentes saídos", 
         caption = "Source: Ministry of Health, Portugal") +

  theme_minimal()

p1
```

### Jitter plot

```{r}
# Let's change the caracteristics of the box plot
# Change the colours and theme
# Dont show the NA in the plot

p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, 
                y = doentes_saidos_var)
            ) +
  geom_jitter(alpha=0.05, # Transparencia 1- sem transparencia 0- transparente
              width = 0.3,
              colour = "gray") +
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  theme_minimal()
p1
```

## COMPARAR QUANTIDADES

**Gráfico de Barras (geom_bar() ou geom_col())**

Descrição: Um gráfico de barras mostra a relação entre uma variável numérica e uma variável categórica. Cada entidade da variável categórica é representada como uma barra. O tamanho da barra representa seu valor numérico.

Uso: O gráfico de barras é às vezes descrito como uma forma monótona de visualizar informações. No entanto, é provavelmente a maneira mais eficiente de mostrar esse tipo de dados. Ordenar as barras e fornecer boas anotações são frequentemente necessários. geom_bar() é usado para dados de contagem, enquanto geom_col() é para dados de soma ou média já calculados.


### Gráfico de Barras (Bar plot)

Vamos criar um novo dataset com a soma de doentes saidos por ano.

```{r}
inpatient_hospital_year <- inpatient_hospital_lite |>
  summarise(
    doentes_saidos_var = sum(doentes_saidos_var, na.rm = TRUE), 
    .by= c(year, tipo_instituicao)
    )
  
    
```

#### Agrupadas (Dodge bar) 

Cria barras agrupadas

```{r}

# Criar um gráfico de barras agrupadas com o conjunto de dados 'inpatient_hospital_year'
p1 <- ggplot(data = inpatient_hospital_year, 
             aes(x = year, 
                 y = doentes_saidos_var,
                 fill = tipo_instituicao)) +  # Definir as variáveis e a cor das barras
  geom_bar(position = "dodge", 
           stat = "identity") +  # Criar barras agrupadas e usar os valores da variável y
  
  labs(title = "Number of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo do gráfico
       y = "Number of inpatients discharged",  # Etiqueta do eixo y
       x = "Year",  # Etiqueta do eixo x, corrigido de "Type of hospital" para "Year"
       caption = "Source: Ministry of Health, Portugal")  # Legenda da fonte de dados

# Exibir o gráfico
p1


```

Podemos definir manualmente as cores e inverter os eixos X e Y

```{r}

# Carregar o pacote necessário para manipulação de cores
library(scales)

# Gerar códigos hexadecimais de cores para um gráfico com três elementos
hex <- hue_pal()(3)
 

# Preparar o conjunto de dados 'inpatient_hospital_year' com fatores ordenados
inpatient_hospital_year <- inpatient_hospital_year |>
  mutate(
    tipo_instituicao = factor(tipo_instituicao, levels = c("Hospital", "University", "Cancer hospital"))
  ) 

# Criar um gráfico de barras agrupadas com várias personalizações
p1 <- ggplot(data = inpatient_hospital_year,
             aes(x = year, 
                 y = doentes_saidos_var,
                 fill = tipo_instituicao)
            ) +
  geom_bar(position = "dodge", 
           stat = "identity"
           ) +
  coord_flip() +  # Inverter os eixos x e y
  scale_y_continuous(labels = comma) +  # Formatar os rótulos do eixo y com vírgulas
  scale_fill_manual(values = hex) +  # Usar cores personalizadas para as barras
  labs(title = "Number of inpatients discharged in Hospitals",
       subtitle = "2015-2022",
       y = "Number of inpatients discharged",
       x = "Type of hospital", 
       caption = "Source: Ministry of Health, Portugal",
       fill = "") +
  theme_minimal() +  # Usar um tema minimalista
  theme(legend.position = "bottom")  # Posicionar a legenda na parte inferior

# Exibir o gráfico
p1


```

#### Empilhadas (Stacked bar) 



```{r}
# Carregar o pacote ggplot2 para visualização de dados
#library(ggplot2)
# library(scales)  # Para usar a função 'comma' na formatação dos rótulos

# Criar um gráfico de barras empilhadas com personalizações
p1 <- ggplot(data = inpatient_hospital_year,
             aes(x = year, 
                 y = doentes_saidos_var,
                 fill = factor(tipo_instituicao, 
                               levels = c("Hospital", "University", "Cancer hospital"))
            )) +
  geom_bar(position = "stack",  # Empilhar as barras
           stat = "identity"  # Usar os valores da variável y
           ) +
  scale_y_continuous(labels = comma) +  # Formatar rótulos do eixo y com vírgulas
  scale_fill_manual(values = c("#00BA38", "#619CFF", "#F8766D")) +  # Cores personalizadas para as barras
  labs(title = "Number of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo
       y = "Number of inpatients discharged",  # Etiqueta do eixo y
       x = "Type of hospital",  # Etiqueta do eixo x
       caption = "Source: Ministry of Health, Portugal",  # Legenda da fonte
       fill = "") +  # Legenda das categorias de 'fill'
  theme_minimal() +  # Tema minimalista
  theme(legend.position = "bottom")  # Posição da legenda

# Exibir o gráfico
p1

```


## COMPARAR PROPORÇÕES

### Gráfico de Barras (Bar plot)

#### Fill

Cria barras de area relativa (percentagem)

```{r}
# Carregar o pacote ggplot2 para visualização de dados
#library(ggplot2)
#library(scales)  # Para usar a função 'percent' na formatação dos rótulos

# Criar um gráfico de barras empilhadas e normalizadas (a 100%)
p1 <- ggplot(data = inpatient_hospital_year,
             aes(x = year, 
                 y = doentes_saidos_var,
                 fill = factor(tipo_instituicao, 
                               levels = c("Hospital", "University", "Cancer hospital"))
            )) +
  geom_bar(position = "fill",  # Normalizar as barras para mostrar a porcentagem
           stat = "identity"  # Usar os valores da variável y
           ) +
  scale_y_continuous(labels = percent) +  # Formatar rótulos do eixo y como percentagens
  scale_fill_manual(values = c("#00BA38", "#619CFF", "#F8766D")) +  # Cores personalizadas para as barras
  labs(title = "Percentage of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo
       y = "Percentage of inpatients discharged",  #  Eixo y
       x = "Type of hospital",  # Etiqueta do eixo x
       caption = "Source: Ministry of Health, Portugal",  
       fill = "") +  # Legenda das categorias de 'fill'
  theme_minimal() +  # Tema minimalista
  theme(legend.position = "bottom")  # Posicionar a legenda na parte inferior

# Exibir o gráfico
p1

```



### Gráfico tarte (Doughnut plot)

Descrição:O gráfico de tarte tem com 'fatias' representando as percentagens de diferentes categorias. A diferença é o espaço em branco no meio, que o faz parecer uma rosca.

Uso: Cada 'fatia' do gráfico representa uma categoria dos dados, e o tamanho da fatia é proporcional à quantidade ou percentagem da categoria em relação ao total.

```{r}

# Criar dados de teste
data <- data.frame(
  category = c("Cancer Hospital", "University", "Hospital"),
  count = c(2, 23, 75)
)
 
# Calcular as percentagens
data$fraction <- data$count / sum(data$count)

# Calcular as percentagens cumulativas (topo de cada retângulo)
data$ymax <- cumsum(data$fraction)

# Calcular a base de cada retângulo
data$ymin <- c(0, head(data$ymax, n = -1))

# Criar o gráfico tipo 'doughnut'
ggplot(data, aes(ymax = ymax, ymin = ymin, xmax = 4, xmin = 3, fill = category)) +
  geom_rect() +  # Usar retângulos para criar as 'fatias' da rosca

  coord_polar(theta = "y") +  # Transformar o gráfico de barras em um gráfico polar (rosca)
  xlim(c(2, 4)) +  # Definir limites para criar um buraco no meio do gráfico
  scale_fill_manual(values = c("#00BA38", "#619CFF", "#F8766D")) +  # Cores personalizadas para as categorias
  
  labs(title = "Percentage of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo
       caption = "Source: Ministry of Health, Portugal",  # Legenda da fonte
       fill = "") +  # Legenda das categorias de 'fill'
  theme_void()  # Usar um tema que remove os eixos e rótulos

```

## RELAÇÕES ENTRE VARIÁVEIS 
  
### Dispersão (Scatterplot)

Um gráfico de dispersão (scatterplot) é uma ferramenta fundamental na análise de dados, utilizada para examinar a relação entre duas variáveis numéricas. Este tipo de gráfico exibe pontos representando a combinação de valores de duas variáveis, uma no eixo horizontal (eixo X) e outra no eixo vertical (eixo Y). A posição de cada ponto no gráfico indica os valores dessas variáveis para cada observação no conjunto de dados. 

```{r}
inpatient_hospital_lite <- inpatient_hospital_lite |>
  filter(dias_de_internamento_var<40000)
```

```{r}

# Criar um gráfico de dispersão usando o conjunto de dados 'inpatient_hospital_lite'
ggplot(data = inpatient_hospital_lite, 
       aes(x = dias_de_internamento_var,  # Variável no eixo X
           y = doentes_saidos_var)         # Variável no eixo Y
       ) + 
  geom_point(alpha = 0.5) +  # Adicionar pontos ao gráfico com transparência
  theme_clean()              # Aplicar um tema limpo e minimalista

```

Adicionar mais elementos

```{r}

# Criar um gráfico de dispersão com personalizações
p1 <- ggplot(data = inpatient_hospital_lite, 
             aes(x = dias_de_internamento_var,  # Variável no eixo X
                 y = doentes_saidos_var,        # Variável no eixo Y
                 colour = tipo_de_especialidade) # Cor para diferenciar as especialidades
             ) + 
  geom_point(alpha = 0.2) +  # Adicionar pontos com transparência
    labs(title = "Number of inpatients discharged and length of stay",  # Título do gráfico
         subtitle = "2015-2022",  # Subtítulo
         y = "Number of inpatients discharged",  # Etiqueta do eixo Y
         x = "Length of stay",  # Etiqueta do eixo X
         caption = "Source: Ministry of Health, Portugal",  # Legenda da fonte
         colour = "") +  # Legenda para a cor
  ylim(0, 3000) +  # Limites para o eixo Y
  xlim(0, 25000) +  # Limites para o eixo X
  theme_minimal() +  # Aplicar um tema minimalista
  theme(legend.position = "bottom")  # Posicionar a legenda na parte inferior

# Exibir o gráfico
p1

```

Podemos adicionar uma condição à cor

```{r}

# Criar um gráfico de dispersão com personalizações
p1 <- ggplot(inpatient_hospital_lite, 
             aes(x = dias_de_internamento_var,  # Variável no eixo X
                 y = doentes_saidos_var,        # Variável no eixo Y
                 colour = dias_de_internamento_var > 10000) # Colorir pontos baseado na condição
             ) + 
  geom_point(alpha = 0.1) +  # Adicionar pontos com transparência
    ylim(0, 3000) +  # Limites para o eixo Y
  xlim(0, 25000) +  # Limites para o eixo X  
  labs(title = "Number of inpatients discharged and length of stay",  # Título do gráfico
         subtitle = "2015-2022",  # Subtítulo
         y = "Number of inpatients discharged",  # Etiqueta do eixo Y
         x = "Length of stay",  # Etiqueta do eixo X
         caption = "Source: Ministry of Health, Portugal") +  # Legenda da fonte
  theme_minimal() +  # Aplicar um tema minimalista
  theme(legend.position = "bottom")  # Posicionar a legenda na parte inferior

# Exibir o gráfico
p1

```

::: callout-warning
**ATENÇÃO** Se queremos definir uma cor temos de definir fora o aes. Podemos definir também o formato da figura.
:::

```{r}

# Criar um gráfico de dispersão com personalizações
p1 <- ggplot(inpatient_hospital_lite, 
             aes(x = dias_de_internamento_var,  # Variável no eixo X
                 y = doentes_saidos_var,        # Variável no eixo Y
                 shape = tipo_de_especialidade) # Diferenciar por tipo de especialidade
             ) + 
  geom_point(alpha = 0.5,                      # Adicionar pontos com transparência
             color = "#0868ac"                 # Cor dos pontos
             ) +
    ylim(0, 3000) +  # Limites para o eixo Y
  xlim(0, 25000) +  # Limites para o eixo X
    labs(title = "Number of inpatients discharged and length of stay",  # Título do gráfico
         subtitle = "2015-2022",  # Subtítulo
         y = "Number of inpatients discharged",  # Etiqueta do eixo Y
         x = "Length of stay",  # Etiqueta do eixo X
         caption = "Source: Ministry of Health, Portugal") +  # Legenda da fonte
  theme_minimal() +  # Aplicar um tema minimalista
  theme(legend.position = "bottom")  # Posicionar a legenda na parte inferior

# Exibir o gráfico
p1

```

#### Adicionar medidas de tendencia

##### Linear

```{r}

p1<- ggplot(inpatient_hospital_lite, 
       aes(x=dias_de_internamento_var, 
           y=doentes_saidos_var, 
           colour=tipo_de_especialidade)) + 
  geom_point(alpha=0.1) +
  geom_smooth(method = lm, # Adicionar uma linha de tendência linear
              se = TRUE,     #  Incluir a banda de erro padrão
              linetype = "dashed") + # Linha tracejada para a linha de tendência
  ylim(0, 3000) +  # Limites para o eixo Y
  xlim(0, 25000) +  # Limites para o eixo X
    labs(title = "Number of inpatients discharged and length of stay",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Length of stay ", 
         caption = "Source: Ministry of Health, Portugal",
       colour="") +
  theme_minimal() +
  theme(legend.position="bottom")

p1

```

##### Não linear

```{r}

p1<- ggplot(inpatient_hospital_lite, 
       aes(x=dias_de_internamento_var, 
           y=doentes_saidos_var)) + 
  geom_point(alpha=0.1
             ) +
  geom_smooth(method = loess, # Adicionar uma linha de tendência LOESS
              se = FALSE,     # Não incluir a banda de erro padrão
              linetype = "dashed") + # Linha tracejada para a linha de tendência
  ylim(0, 3000) +  # Limites para o eixo Y
  xlim(0, 25000) +  # Limites para o eixo X
  labs(title = "Number of inpatients discharged and length of stay",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Length of stay ", 
         caption = "Source: Ministry of Health, Portugal",
       colour="") +
  theme_minimal() +
  theme(legend.position="bottom")

p1

```



## Gráfico de linhas (Line plot)

Descrição: Um gráfico de linhas ou gráfico linear exibe a evolução de uma ou várias variáveis numéricas. Os pontos de dados são conectados por segmentos de linha reta. É semelhante a um gráfico de dispersão, exceto que os pontos de medição são ordenados (tipicamente pelo seu valor no eixo x) e unidos com segmentos de linha reta.

Uso: Um gráfico de linhas é frequentemente usado para visualizar uma tendência nos dados ao longo de intervalos de tempo -- uma série temporal -- portanto, a linha é frequentemente desenhada de forma cronológica.

```{r}
inpatient_hospital_sum <- inpatient_hospital_lite |>
  summarise(
    doentes_saidos_var = sum(doentes_saidos_var, na.rm = TRUE)
    ,.by = c(periodo, tipo_instituicao))
    
```

### Gráfico de linhas

```{r}
# Criar um gráfico de linhas com personalizações
p1 <- ggplot() +
  
  geom_line(data = inpatient_hospital_sum,   # Usar dados de 'inpatient_hospital_sum'
            aes(x = periodo,                 # Definir 'periodo' como variável do eixo X
                y = doentes_saidos_var,      # Definir 'doentes_saidos_var' como variável do eixo Y
                colour = tipo_instituicao)) + # Diferenciar as linhas por 'tipo_instituicao'

  labs(title = "Number of inpatients discharged in Hospitals",  # Título do gráfico
       subtitle = "2015-2022",  # Subtítulo
       y = "Number of inpatients discharged",  # Etiqueta do eixo Y
       x = "Type of hospital",  # Etiqueta do eixo X
       caption = "Source: Ministry of Health, Portugal") +  # Legenda da fonte

  theme_minimal()  # Aplicar um tema minimalista

# Exibir o gráfico
p1


```

#### Alterar o posicionamento da legenda

```{r}

p1<- ggplot() +
  geom_line(data= inpatient_hospital_sum, 
            aes(x = periodo, 
                y = doentes_saidos_var,
                colour=tipo_instituicao)) +
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "", 
         caption = "Source: Ministry of Health, Portugal",
       colour = "") +
  theme_minimal() +
  theme(legend.position="bottom",
        legend.title=element_blank(),
        plot.title = element_text(face = "bold", size = 12)
        )

p1

```

#### Alterar a cor e tipo da linha

```{r}

p1<- ggplot() +
  geom_line(data= inpatient_hospital_sum, 
            aes(x = periodo, 
                y = doentes_saidos_var,
                colour=tipo_instituicao), 
                linewidth=1.15) + #nos geom de linha o argumento size também funciona para a grossura mas está a mudar para linewidth
  
  scale_color_manual(values = c("#fdb462", "#80b1d3", "#b3de69")) +
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "", 
         caption = "Source: Ministry of Health, Portugal",
       colour = "") +
  theme_minimal() +
  theme(legend.position="bottom",
        legend.title=element_blank(),
        plot.title = element_text(face = "bold", size = 12)
        )

p1

```

#### Adicionar outros elementos

```{r}
p2<- ggplot() +
  geom_line(data= inpatient_hospital_sum, 
            aes(x = periodo, 
                y = doentes_saidos_var,
                colour=tipo_instituicao), 
                linewidth=1.15) +
  
  scale_color_manual(values = c("#fdb462", "#80b1d3", "#b3de69")) +
  
  geom_vline(xintercept=as.Date("2020-03-01"), 
             colour="red") + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "", 
         caption = "Source: Ministry of Health, Portugal",
       colour = "") +
  theme_minimal() +
  theme(legend.position="bottom",
        legend.title=element_blank(),
        plot.title = element_text(face = "bold", size = 12)
        )

p2
	
```



```{r}

p2<- ggplot(data= inpatient_hospital_sum, 
            aes(x = periodo, 
                y = doentes_saidos_var,
                colour=tipo_instituicao)
            ) +
  geom_line(linewidth=1.15) +
  
  scale_color_manual(values = c("#fdb462", "#80b1d3", "#b3de69")) +
  
  geom_vline(xintercept=as.Date("2020-03-01"), 
             colour="red") + 
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "", 
         caption = "Source: Ministry of Health, Portugal",
       colour = "") +
  theme_minimal() +
  theme(legend.position="bottom",
        legend.title=element_blank(),
        plot.title = element_text(face = "bold", size = 12)
        )

p2

```

::: callout-note
Embora não seja necessário, existe um espaço entre o gráfico e os eixos. Para eliminar esse espaço podemos adicionarpo seguinte código:

coord_cartesian( expand = FALSE )
:::

## Gráfico Área (Area chart)

O Gráfico de Área (Area chart) é uma forma de visualização de dados frequentemente utilizada para representar quantidades numéricas ao longo do tempo, sendo semelhante ao gráfico de linhas, mas com as áreas abaixo das linhas preenchidas. Este tipo de gráfico é útil para destacar a magnitude das mudanças ao longo do tempo, oferecendo uma visão clara do volume ou da quantidade dentro de um determinado período.

```{r}
p1<-  ggplot( data = inpatient_hospital_year,
            aes(x = year, 
                y = doentes_saidos_var,
                fill=factor(tipo_instituicao, 
                levels = c("Hospital", 
                           "University", 
                           "Cancer hospital"))
                )
            ) +
  
  geom_area(position="stack",
            alpha=0.6, 
            size=0.1, 
            colour="black"
           ) +
  
  scale_y_continuous(labels = comma) +
  
  scale_fill_manual(values=c("#00BA38","#619CFF" ,"#F8766D")) +
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "", 
         caption = "Source: Ministry of Health, Portugal",
         fill="") +
  theme_minimal() +
  theme(legend.position="bottom")

p1
```

## VISUALIZAR INCERTEZA

### Barras de erro (Error Bars)


As barras de erro (Error Bars) são uma ferramenta crucial em gráficos para representar a incerteza nos dados. Elas permitem aos espectadores compreender a variabilidade ou a precisão das medidas,

```{r}

inpatient_hospital_year_mean <- inpatient_hospital_lite |>
  summarise(
    mean_saidos_var = mean(doentes_saidos_var, na.rm = TRUE), 
    sd_saidos_var = sd(doentes_saidos_var, na.rm = TRUE), 
    .by= c(year)
    )
  
    
```



```{r}
p3<- ggplot(data= inpatient_hospital_year_mean, 
            aes(x = year, 
                y = mean_saidos_var) 
            ) +
  
  geom_point()+
  
geom_errorbar(aes(ymin = mean_saidos_var - sd_saidos_var,  # Limite inferior da barra de erro
                  ymax = mean_saidos_var + sd_saidos_var), # Limite superior da barra de erro
              width = .2,                                  # Largura das 'barras' horizontais nas extremidades
              position = position_dodge(0.05))  +           # Ajuste da posição para evitar sobreposição

  
  labs(
#    title = "Mean and SD of inpatients discharged",
#         subtitle = "2015-2022",
         y = "Mean number",
#         x = "Year", 
#         caption = "Source: MoH, Portugal"
) +
  theme_minimal()

p3

```

### Confidence intervals

```{r}

p1<- ggplot(inpatient_hospital_lite, 
       aes(x=dias_de_internamento_var, 
           y=doentes_saidos_var)) + 

  geom_smooth(method=loess, 
              se=TRUE,
              span = 0.1) +
  
    labs(title = "Number of inpatients discharged and length of stay",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Length of stay ", 
         caption = "Source: Ministry of Health, Portugal",
       colour="") +
  theme_minimal() +
  theme(legend.position="bottom")

p1

```

::: callout-note
A função geom_ribbon no ggplot2 do R é uma ferramenta poderosa para visualizar intervalos de confiança ou outras áreas de incerteza em torno de uma linha num gráfico. 

geom_ribbon é usada no ggplot2 para adicionar uma "faixa" ou "área" sombreada ao gráfico. Esta faixa é definida por duas linhas, uma representando o limite superior e outra o limite inferior do intervalo que se deseja destacar.
:::


## ESTATÍSTICAS EM GRÁFICOS (STATISTICS)

Podemos adicionar medidas estatísticas directamente nos gráficos sem necessidade de as calcular previamente.

```{r}

# Criar um gráfico com características personalizadas
p1 <- ggplot(data = inpatient_hospital_lite, 
             aes(x = tipo_instituicao, 
                 y = doentes_saidos_var)
             ) +
  stat_summary(
    geom = "point",     # Adicionar pontos representando a mediana
    fun.y = "median",   # Função para calcular a mediana
    col = "black",      # Cor dos pontos
    size = 3,           # Tamanho dos pontos
    shape = 2,          # Forma dos pontos
    fill = "black") +   # Cor de preenchimento dos pontos
  
  geom_jitter(          # Adicionar jitter para mostrar a dispersão
    alpha = 0.02,       # Transparência dos pontos do jitter
    width = 0.3,        # Largura do jitter
    colour = "gray") +  # Cor dos pontos do jitter
  
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  
  theme_minimal()

p1
```

```{r}

p1<- ggplot(data= inpatient_hospital_lite, 
            aes(x = tipo_instituicao, 
                y = doentes_saidos_var)
            ) +
    stat_summary(
      geom = "point",
      fun.y = "mean",
      col = "black",
      size = 3,
      shape = 3) +
  stat_summary(
    geom = "point",
    fun.y = "median",
    col = "red",
    size = 3,
    shape = 1) +
  ylim(0, 4000) +
  geom_jitter(alpha=0.02,
              width = 0.2,
              colour = "gray") +
  labs(title = "Number of inpatients discharged in Hospitals",
         subtitle = "2015-2022",
         y = "Number of inpatients discharged",
         x = "Type of hospital", 
         caption = "Source: Ministry of Health, Portugal") +
  theme_minimal()
p1
```


## COMBINAR PLOTS

O pacote patchwork no R oferece uma solução elegante para combinar e organizar múltiplos gráficos criados com ggplot2. Esta biblioteca destaca-se pela  simplicidade e flexibilidade, permitindo aos utilizadores dispor gráficos de forma intuitiva numa única janela gráfica, facilitando a comparação e a análise conjunta de diferentes visualizações. 

Ver mais aqui <https://patchwork.data-imaginist.com/articles/patchwork.html>




```{r}
library(patchwork)
p2 + p3  # Combina 'p2' e 'p3' lado a lado
```

```{r}

p2 / p3  # Empilha 'p2' sobre 'p3'

```


# DADOS ESPACIAIS 

## Tipos de dados espaciais 

**Dados de áreas**: Este tipo de dados representa o espaço geográfico através de pontos, linhas e polígonos. Polígonos são utilizados para áreas maiores como lagos, parques ou fronteiras de países.

**Dados Raster (grelha)**: São dados que representam o espaço geográfico como uma matriz de células ou pixels, com cada célula tendo um valor específico. Imagens de satélite e mapas de elevação são exemplos típicos de dados raster. 

**Dados localização (Point data)**: São dados que correspondem a uma localização especifica no espaço. p.e. localização de uma estação meteorologica. 

## Shapefiles 

Os dados espaciais são frequentemente representados através de um formato de armazenamento de dados denominado shapefile. 

Podemos encontrar shapefiles de diversas fontes, p.e. Ministério da Administração Interna, ao Eurostat, https://ec.europa.eu/eurostat/web/gisco/overview 


```{r}
# Carregar o pacote giscoR para obter dados geográficos
library(giscoR)

# Obter os dados geográficos (shapefile) de Portugal com uma resolução de 10M
# e adicionar uma nova coluna 'res' com o valor "10M"
PT_res10 <-
  gisco_get_countries(resolution = "10", 
                      country = "PT") %>%
  mutate(res = "10M")

```


```{r}
# Utilizar ggplot para criar um mapa de Portugal
# geom_sf desenha as fronteiras de Portugal, preenchendo o interior de azul
# theme_map aplica um tema adequado para mapas
ggplot(PT_res10) +
  geom_sf(fill = "blue") +
  theme_map()

```

```{r}
# Obter dados geográficos das regiões NUTS de Portugal (nível 2)
PT_nuts <- gisco_get_nuts(country = "Portugal", nuts_level = 2)

# Criar um mapa das regiões NUTS
# geom_sf desenha as fronteiras das regiões
# geom_sf_text adiciona rótulos às regiões
# theme_map aplica um tema adequado para mapas
ggplot(PT_nuts) +
  geom_sf() +
  geom_sf_text(aes(label = NAME_LATN), size = 2) +
  theme_map()

```

```{r}
# Definir as regiões a serem excluídas do mapa
target <- c("Região Autónoma dos Açores", "Região Autónoma da Madeira")

# Filtrar os dados, excluindo as regiões definidas em 'target'
PT_nuts <- PT_nuts |> 
  filter(! NUTS_NAME %in% target)

# Criar um mapa das regiões NUTS, excluindo Açores e Madeira
# geom_sf desenha as fronteiras das regiões
# geom_sf_text adiciona rótulos menores às regiões
# theme_map aplica um tema adequado para mapas
ggplot(PT_nuts) +
  geom_sf() +
  geom_sf_text(aes(label = NAME_LATN), size = 2) +
  theme_map()

```

#### Mapas 

Por vezes podemos carregar a shapefile e os dados e juntar os dados, desde que tenhamos um identificador comum

```{r}
# Carregar o pacote sf para trabalhar com dados espaciais
library(sf)

# Ler a shapefile dos concelhos de Portugal a partir de um arquivo JSON
comm_pt <- st_read("datasets/map_json_portugal/concelhos_portugal_light.json")

```

```{r}
# Ler dados de incidência de COVID-19 de um arquivo CSV
covid_inc <- read_csv("datasets/covid_inc.csv") 

# Renomear a coluna 'Concelho' para 'NAME_2' para correspondência com a shapefile
# e ajustar a nomenclatura de alguns concelhos
covid_inc <- covid_inc |>
  rename(NAME_2 = Concelho) |>
  mutate(NAME_2 = recode(NAME_2,
                         'Ponte de Sor' = "Ponte de Sôr"
                         ))

# Nota sobre erros frequentes com nomes de concelhos como Lagoa, Calheta, Mealhada, Sátão
```


```{r}

# Combinar a shapefile com os dados de COVID-19 usando a função left_join
# A combinação é feita com base no nome dos concelhos (NAME_2)
comm_pt <- left_join(comm_pt,
                     covid_inc,
                     by = "NAME_2")

# Identificar as entradas na shapefile que não têm correspondência nos dados de COVID-19
sanity <- anti_join(comm_pt,
                    covid_inc,
                    by = "NAME_2")

```


**Color**
Função: 
A estética color é usada para definir a cor das linhas ou bordas de um objeto no gráfico. No contexto de mapas, color define a cor das fronteiras ou linhas que delimitam as unidades geográficas (como países, regiões, estados, etc.).

Exemplo: 
geom_sf(color = "black") desenha as fronteiras de unidades geográficas em preto.

**Fill**
Função: 
A estética fill é usada para definir a cor de preenchimento do interior de um objeto. Em mapas, fill define a cor dentro das fronteiras das unidades geográficas.

Exemplo: 
geom_sf(aes(fill = variavel)) preenche as áreas internas das unidades geográficas com cores que podem variar de acordo com uma variável, como a densidade populacional, categorias de dados, etc.

```{r}

# Criar um mapa temático dos concelhos de Portugal
p1 <- ggplot() + 
  geom_sf(data = comm_pt,                   # Usar os dados geográficos de 'comm_pt'
          aes(fill = Incidencia_categoria), # Preencher áreas com base na 'Incidencia_categoria'
          size = 1,                         # Definir o tamanho das linhas das fronteiras
          color = "black"                   # Cor das linhas das fronteiras
         ) 

# Exibir o mapa
p1

```


```{r}

# Criar um mapa temático dos concelhos de Portugal
p1 <- ggplot() + 
  geom_sf(data = comm_pt,                      # Usar os dados geográficos de 'comm_pt'
          aes(fill = Incidencia_categoria),    # Preencher áreas com base na 'Incidencia_categoria'
          size = 0.1,                          # Definir o tamanho das linhas das fronteiras
          color = "white"                      # Cor das linhas das fronteiras
          ) 

# Exibir o mapa
p1

```

Adicionar o tema e título 

```{r}
# Criar um mapa temático de Portugal com dados de incidência de COVID-19
p <- ggplot() +
    geom_sf(data = comm_pt,                  # Usar dados geográficos 'comm_pt'
            aes(fill = Incidencia_categoria),# Preencher áreas com base na categoria de incidência
            size = 0.1,                      # Definir espessura das linhas de fronteira
            color = "white"                  # Cor das linhas de fronteira
           ) +
    # Aplicar um tema clássico para um visual limpo e tradicional
    theme_classic() +
    # Personalizar rótulos e títulos
    labs(x = NULL,                           # Remover rótulo do eixo X
         y = NULL,                           # Remover rótulo do eixo Y
         title = "Portugal's COVID-19 incidence", # Título do mapa
         subtitle = "January, 2022",              # Subtítulo do mapa
         caption = "Data: DGS, 2022")             # Legenda dos dados

p  # Exibir o mapa

```

Podemos alterar o tema 

```{r}
theme_map <- function(...) {
  theme_minimal() +                    # Começa com o tema minimalista do ggplot2
  theme(
    axis.line = element_blank(),       # Remove as linhas dos eixos
    axis.text.x = element_blank(),     # Remove o texto do eixo X
    axis.text.y = element_blank(),     # Remove o texto do eixo Y
    axis.ticks = element_blank(),      # Remove os ticks (marcadores) dos eixos
    axis.title.x = element_blank(),    # Remove o título do eixo X
    axis.title.y = element_blank(),    # Remove o título do eixo Y
    panel.grid.major = element_blank(),# Remove as grades principais do painel
    panel.grid.minor = element_blank(),# Remove as grades menores do painel
    panel.border = element_blank(),    # Remove a borda do painel
  )
}

```

```{r}
p <- ggplot() +
    geom_sf(data = comm_pt, 
          aes(fill = Incidencia_categoria),
              size = 0.1,
              color = "white"
          ) +
    # add the theme
   theme_map() +
    labs(x = NULL, 
         y = NULL, 
         title = "Portugal's COVID-19 incidence", 
         subtitle = "January, 2022", 
         caption = "Data: DGS, 2022")
p


```

Podemos alterar as cores agora 

::: callout-note

Este website é um optimo recurso para escolher cores <https://colorbrewer2.org/>
:::

```{r}

# Definir um vetor de cores para as categorias de incidência
cols <- c("#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000")

# Criar um mapa temático de Portugal com dados de incidência de COVID-19
p <- ggplot() +
    geom_sf(data = comm_pt,                     # Usar os dados geográficos 'comm_pt'
            aes(fill = Incidencia_categoria),   # Preencher áreas com base na categoria de incidência
            size = 0.1,                         # Definir espessura das linhas de fronteira
            color = "gray"                      # Cor das linhas de fronteira
           ) +
    # Aplicar o tema personalizado para mapas
    theme_map() +
    # Personalizar rótulos e títulos
    labs(x = NULL,                             # Remover rótulo do eixo X
         y = NULL,                             # Remover rótulo do eixo Y
         title = "Portugal's COVID-19 incidence", # Título do mapa
         subtitle = "January, 2022",            # Subtítulo do mapa
         caption = "Data: DGS, 2022") +         # Legenda dos dados
    # Personalizar a escala de cores para a variável 'Incidencia_categoria'
    scale_fill_manual(values = cols,
                      name = "Incidence") +
    # Ajustar a posição e estilo da legenda
    theme(
      legend.position = "right",
      legend.direction = "vertical",
      legend.text = element_text(size = 8, colour = "gray50")
    )

# Exibir o mapa
p

```


#### Operações com shapefiles 

**Criação de Geometrias:** st_sfc() e st_sf() são usados para criar objetos de geometria simples ou um dataframe espacial, respectivamente.

**Operações Geométricas:** Funções como st_union(), st_intersection(), st_difference() são utilizadas para realizar operações geométricas entre objetos espaciais.

::: callout-note

Este website é um optimo recurso <file:///Users/andreperaltasantos/Downloads/sf.pdf>
:::


```{r}
comm_ars <- comm_pt |>                # Usar o conjunto de dados 'comm_pt'
  group_by(ARS) |>                    # Agrupar os dados pela variável 'ARS'
  summarize(geometry = st_union(geometry) # Combinar as geometrias dentro de cada grupo
            )

```

Podemos adicionar as fronteiras das ARS

```{r}
p <- ggplot() +
      geom_sf(data = comm_pt, 
          aes(fill = Incidencia_categoria),
              size = 0.1,
              color = "gray"
          ) +
        geom_sf(data = comm_ars, 
              size = 0.1,
              color = "black",
              alpha = 0
          ) +
    # add the previously defined basic theme
   theme_map() +
    labs(x = NULL, 
         y = NULL, 
         title = "Portugal's COVID-19 incidence", 
         subtitle = "January, 2022", 
         caption = "Data: DGS, 2022") +
    # and we use guide_legend instead of guide_colourbar
  scale_fill_manual(values = cols,
                    name = "") +
  theme(legend.position = "right",
        legend.direction = "vertical",
        legend.text = element_text(size = 8, colour = "black")) 
p
```


#### Mapa Europeu 

Podemos descarregar os mapas das NUTS directamente do pacote giscoR. Neste caso vamos fazer o download de NUTS0 (paises)

```{r}
# Carregar o pacote giscoR
library(giscoR)

# Obter dados geográficos dos NUTS nível 0 para o ano de 2016
# NUTS nível 0 geralmente se refere a grandes regiões ou países
nuts0 <- gisco_get_nuts(
  year = "2016",        # Ano dos dados
  epsg = "3035",        # Sistema de coordenadas espaciais 
  resolution = "3",     # Resolução dos dados (3 = baixa resolução)
  nuts_level = "0"      # Nível NUTS (0 = nível mais alto)
)

```

Podemos obter dados do Eurostat directamente do pacote eurostat. 

Podemos explorar mais aqui <https://ropengov.github.io/eurostat/articles/eurostat_tutorial.html> 


```{r}
# Carregar o pacote eurostat
library(eurostat)

# Baixar o conjunto de dados de expectativa de vida saudável do Eurostat
healthy_life_expectancy <- get_eurostat("hlth_silc_17") |>
  # Filtrar para o ano de 2021, sexo total (ambos os sexos) e indicador de expectativa de vida saudável ao nascer
  filter(TIME_PERIOD == "2021-01-01", 
         sex == "T", 
         indic_he == "HE_BIRTH"
         )

```

Os passos para gerar o mapa são 1. Juntar os dados, 2. Definir as categorias, 3. criar o mapa

```{r}
# Combinar os dados NUTS com os dados de expectativa de vida saudável
nuts0.sf <- nuts0 |> 
  left_join(healthy_life_expectancy, by = c("NUTS_ID" = "geo"))
```


```{r}
# Definir intervalos para categorização
br <- c(0, 68, 70, 75, 77, 80, 85)

# Categorizar os dados de expectativa de vida
nuts0.sf <- nuts0.sf %>%
  mutate(values_cut = cut(values, br, dig.lab = 6))


labs_plot <- prettyNum(br[-1], big.mark = ",")

# Paleta de cores 
pal <- hcl.colors(length(br) - 1, "Lajolla")

```


```{r}
# Criar um mapa temático com ggplot2
p_map <- ggplot(nuts0.sf) +
  # Adicionar as regiões NUTS com preenchimento baseado na expectativa de vida saudável
    # Adicionar linhas de fronteira dos países
  geom_sf(data = nuts0.sf, 
          col = "black",  # Cor das linhas de fronteira
          linewidth = 0.1) + # Espessura das linhas de fronteira
  
  geom_sf(aes(fill = values_cut), 
          linewidth = 0,  # Linhas de fronteira sem largura
          color = NA,     # Sem cor de linha
          alpha = 0.9) +  # Transparência das cores de preenchimento

  # Configurar as coordenadas para centralizar na Europa (EPSG 3035)
  coord_sf(
    xlim = c(2377294, 7453440),
    ylim = c(1313597, 5628510)
  ) +
  # Adicionar rótulos ao mapa
  labs(
    title = "Healthy Life Expectacy in the EU", # Título
    subtitle = "2021", # Subtítulo
    caption="Data: Eurostat"
  ) +
  # Configurar a escala de cores manualmente
  scale_fill_manual(
    name = "Years",       # Nome da legenda
    values = pal,         # Paleta de cores
    labels = labs_plot,   # Rótulos para as categorias de cor
    drop = FALSE,         # Manter todas as categorias na legenda
    guide = guide_legend( # Configurar a aparência da legenda
      direction = "horizontal",
      keyheight = 0.4,
      keywidth = 1.5,
      title.position = "top",
      title.hjust = 0.5,
      label.hjust = .5,
      nrow = 1,
      byrow = TRUE,
      reverse = FALSE,
      label.position = "bottom"
    )
  ) +
  # Aplicar um tema personalizado para mapas
  theme_map() +
  # Personalizar aspectos adicionais do tema
  theme(
    plot.caption = element_text(
      size = 8, color = "grey60"
      ),
    legend.text = element_text(
      size = 8,
      color = "grey20"
    ),
    legend.title = element_text(
      size = 9,
      color = "grey20"
    ),
    legend.position = "bottom" # Posição da legenda
  )

p_map
```

```{r}
ggsave(
  p_map,
  filename = here::here("output", 
                        "figures", 
                        paste0( "map_eu_HE", ".png")),
  width = 10,
  height = 8,
  units = c("cm"),
  dpi = "retina",
  bg = "white"
)
```


### Dados Raster  

Os dados raster são uma forma fundamental de representação de dados espaciais, especialmente utilizados em análises geográficas e de remote sensing. Em comparação comos dados vetoriais, que representam características geográficas como pontos, linhas e polígonos, os dados raster são formados por células (ou pixels) organizados em uma grade regular (latice). Cada célula de um raster tem um valor associado, que pode representar diversas informações, como temperatura, altitude, umidade, etc.

```{r}
# Carregar o pacote geodata para trabalhar com dados geoespaciais
library(geodata)

# Obter dados climáticos (temperatura média) para Portugal
tavg_pt <- worldclim_country(country = "Portugal", 
                             var = "tavg",
                             path = tempdir())

# Converter os dados raster para um data.frame
tavg_pt_df <- as.data.frame(tavg_pt, xy = TRUE) 


```

```{r}

# Criar um mapa temático da temperatura média em Portugal
g_tmax_map <- ggplot(data = tavg_pt_df) +
    geom_raster(aes(x = x, y = y, 
                    fill = PRT_wc2.1_30s_tavg_1)) + # Usar 'geom_raster' para criar o mapa temático

    theme_void() + # Aplicar um tema sem elementos extras
    theme(
      legend.position = "bottom")  +
    scale_fill_viridis_c(name = "Temperatura Média") + # Usar uma escala de cores 'viridis' para a temperatura
    labs(
      title = "Temperatura Média em Portugal", # Título do mapa
      caption = "Source: Eurostat" # Fonte dos dados
    ) 
# Exibir o mapa
g_tmax_map

```


### Dados de Localização

Os dados de localização são pontos de coordenadas (lat, long) que podemos adicionar à nossa shapefile.

```{r}
# Filtrar só para a ARS de Lisboa e Vale do Tejo
comm_lvt<- comm_pt |>
  filter(ARS=="Lisboa e Vale do Tejo")  

# Contem as coordenadas dos hospitais do SNS em Porugal
geo_hospitals <-  read_csv("datasets/geo_location_hospitals.csv")
  
```

```{r}
p <- ggplot() +
        geom_sf(data = comm_lvt, 
              size = 0.2,
              color = "black",
              fill="gray",
              alpha = 0.3
          ) +
      geom_point(data = geo_hospitals, 
                 aes(x = long, 
                     y = lat), 
                 size = 2, 
                 shape = 23, 
                 fill = "red",
                 alpha=0.5) +
  
      # Usar geom_text ou geom_label para adicionar rótulos
      geom_text(data = geo_hospitals,
                aes(x = long, 
                    y = lat, 
                    label = Hospital),
                check_overlap = TRUE, 
                size = 2,
                nudge_y = 0.05 
                ) +
   theme_map() +
    labs(x = NULL, 
         y = NULL, 
         title = "Portugal's Hospital location in Lisbon and Tagus Valey", 
         subtitle = "January, 2022", 
         caption = "Data: MoH, 2022") 
p

```

### Open Streep maps

O OpenStreetMap (OSM) é um projeto colaborativo que cria mapas livres e editáveis do mundo, semelhante à Wikipedia, mas para mapas. Fornece dados geográficos acessíveis e atualizados que são úteis para uma variedade de aplicações, desde navegação e planejamento urbano até análises geoespaciais e projetos de pesquisa.

O osmdata é um pacote no R que permite manipular os dados do OpenStreetMap diretamente do R. É uma ferramenta para cientistas de dados e pesquisadores que trabalham com dados geoespaciais. 

::: callout-warning

Por vezes pode ser necessario reiniciar o R depois de instalar o osmdata
:::

```{r}
# Carregar pacotes necessários
library(osmdata)
library(ggplot2)


```

```{r}
# Definir a área de Lisboa
bbox_lisbon <- getbb("Lisbon, Portugal")

```

```{r}
# Consultar e obter dados de instalações de saúde
health_data <- opq(bbox = bbox_lisbon) %>%
  add_osm_feature(key = "amenity", value = "hospital") %>%
  osmdata_sf()

# Consultar e obter dados das ruas principais (primary e secondary)
streets_data <- opq(bbox = bbox_lisbon) %>%
  add_osm_feature(key = "highway", value = c("primary", "secondary")) %>%
  osmdata_sf()

```



```{r}
# Preparar os dados para construir o grafico
health_facilities <- health_data$osm_points
main_streets <- streets_data$osm_lines

# Criar o mapa com ggplot2
ggplot() +
    # Adicionar ruas principais
    geom_sf(data = main_streets, 
            color = "gray", 
            size = 0.15) +
    # Adicionar instalações de saúde
    geom_sf(data = health_facilities, 
            color = "blue", 
            size = 1.5,
            alpha=0.3) +
    # Configurar tema e rótulos
   theme_map() +
    labs(title = "Instalações de Saúde e Ruas Principais em Lisboa",
         subtitle = "Dados do OpenStreetMap",
         caption = "Fonte: OpenStreetMap") 

```



### Mapas Interactivos (leaflet) 

O Leaflet para R é usado para criar mapas interativos que podem ser integrados em relatórios R Markdown, aplicativos Shiny ou páginas da web. Esses mapas podem incluir funcionalidades como zoom, pan e layers interativos.

Personalização: Oferece ampla personalização de mapas, ver mais aqui <https://rstudio.github.io/leaflet/>

```{r}

# Preparar as cores usadas
mybins <- c(0,60,120,240,480,Inf)
mycolors <- c("#f7f7f7","#fee391","#fb6a4a","#cb181d","#67000d")
mypalette <- colorBin( palette=mycolors, domain=comm_pt$Incidencia, na.color="transparent", bins=mybins)

# Preparar o texto da legenda interactiva
mytext <- paste(
    "Concelho: ", comm_pt$NAME_2,"<br/>",
    "Incidência: ", comm_pt$Incidencia, 
    sep="") %>%
  lapply(htmltools::HTML)


```

```{r}
# Carregar o pacote leaflet
library(leaflet)

# Criar um mapa interativo com leaflet
p <- leaflet(comm_pt) |> # Inicializar o mapa com os dados 'comm_pt'
  setView(lat=39.5, lng=-7.6, zoom=6) |> # Definir a visualização inicial (foco em Portugal)
  addProviderTiles(providers$CartoDB.Positron) |> # Adicionar tiles de base do CartoDB (estilo Positron)
  addPolygons(
    fillColor = ~mypalette(Incidencia), # Definir a cor de preenchimento dos polígonos baseada em 'Incidencia'
    stroke=TRUE,                       # Ativar as bordas dos polígonos
    fillOpacity = 0.9,                 # Definir a opacidade de preenchimento
    color="grey",                      # Definir a cor da borda dos polígonos
    weight=0.3,                        # Definir a espessura da borda dos polígonos
    label = mytext,                    # Adicionar rótulos aos polígonos
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"), # Estilo dos rótulos
      textsize = "13px",              # Tamanho do texto dos rótulos
      direction = "auto"              # Direção automática dos rótulos
    )) |> 
  addMiniMap() # Adicionar um mini-mapa para navegação

# Exibir o mapa
p

```


# EXTENÇÕES

As extensões ggplot2 são pacotes no R que ampliam a funcionalidade do ggplot2. Estas extensões adicionam novas camadas, temas, escalas e outras funcionalidades, permitindo aos usuários criar gráficos mais complexos e personalizados. 

Aqui estão algumas das extensões ggplot2 mais populares e suas funcionalidades:

**gganimate:** Permite criar animações com ggplot2. Com gganimate, você pode transformar gráficos estáticos em animações para mostrar mudanças nos dados ao longo do tempo ou destacar movimentos ou transições.

**ggridges:** Usado para criar gráficos de "ridgeplot", que são úteis para visualizar a distribuição de uma variável contínua ao longo de várias categorias. Esses gráficos são uma alternativa esteticamente agradável aos gráficos de densidade ou violino.

**ggforce:** Fornece uma variedade de funcionalidades que não estão disponíveis no ggplot2 padrão, como links geométricos entre pontos, gráficos de densidade facetados e muito mais.

**patchwork:** Uma biblioteca para combinar vários gráficos ggplot2 em um único layout. É muito útil para criar painéis de gráficos complexos.

**ggrepel:** Oferece melhorias na forma como os rótulos de texto são adicionados aos gráficos. Ajuda a evitar a sobreposição de texto, tornando os gráficos mais legíveis.

[extensions of ggplot2](https://exts.ggplot2.tidyverse.org/gallery/)

**esquisse:** é um add-in para R que permite criar e personalizar visualizações de dados interativas com ggplot2 e filtrar dados com dplyr. Ele fornece uma interface gráfica intuitiva que facilita a criação de gráficos, mesmo para usuários que não estão familiarizados com a sintaxe do ggplot2. Aqui estão algumas de suas principais características:

Interface de Arrastar e Soltar: esquisse oferece uma interface de arrastar e soltar para mapear suas variáveis em diferentes estéticas, tornando a criação de gráficos rápida e acessível. <https://dreamrs.github.io/esquisse/index.html>

# FIM 
